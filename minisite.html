<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Minisite</title>
	<style>
		img { height: 200px; }
	</style>
	<script>
		const opening_tag_regex = /\[([^\[\]]+)\]/;
		const self_closing_tag_regex = /\[\/([^\[\]]+)\]/;

		class Node {

			constructor(tag_name, child_nodes, data) {
				this.tag_name = tag_name; // string
				this.child_nodes = child_nodes; // array of Nodes
				this.data = data; // string
			}

			children_html() {

				let construct = "";

				for (let child of this.child_nodes) {
					construct += child.to_html();
				}

				return construct;
			}

			to_html() {

				switch (this.tag_name) {
					case "text": return this.data;
					case "h1": return "<h1>" + this.children_html() + "</h1>";
					case "h2": return "<h2>" + this.children_html() + "</h2>";
					case "a": return "<a href='" + this.data + "'>" + this.children_html() + "</a>";
					case "br": return "<br>";
					case "img": return `<img src="${ this.data }" alt="${ this.children_html() }">`;
					case "bul": return "<ul><li>" + this.children_html() + "</li></ul>";
					default: return this.children_html(); // return "<fieldset><legend>" + this.tag_name + "</legend>" + this.children_html() + "</fieldset>";
				}
			}
		}

		function parse(string) { // recursive function, returns { nodes: list of node objects, string: reduced string after parsing }

			// no more siblings to parse
			if (string.length == 0 || string.startsWith("[/]")) {

				return {
					nodes: [],
					string: string
				};
			}

			// parse next SELF-CLOSING sibling node
			if (string.search(self_closing_tag_regex) == 0) {

				const tag = self_closing_tag_regex.exec(string);

				string = string.substring(tag[0].length); // remove tag

				({ nodes, string } = parse(string)); // parse following siblings

				// parse out tag name from data
				let tag_parts = tag[1].split(" ", 2);

				return {
					nodes: [ new Node(tag_parts[0], [], tag_parts[1]) ].concat(nodes),
					string: string
				};
			}

			// parse next sibling node
			if (string.search(opening_tag_regex) == 0) {

				const opening_tag = opening_tag_regex.exec(string);

				string = string.substring(opening_tag[0].length);	// remove opening tag
				({ nodes, string } = parse(string));				// parse child nodes of this node
				string = string.replace("[/]", "");					// remove closing tag

				let children = nodes;

				({ nodes, string } = parse(string)); // parse following siblings

				// parse out tag name from data
				let tag_parts = opening_tag[1].split(" ", 2);

				return {
					nodes: [ new Node(tag_parts[0], children, tag_parts[1]) ].concat(nodes),
					string: string
				};
			}

			// parse next sibling TEXT node
			const end_of_text_node = string.search(opening_tag_regex) != -1 ? string.search(opening_tag_regex) : string.indexOf("[/]") != -1 ? string.indexOf("[/]") : string.length;

			const text = string.substring(0, end_of_text_node);
			string = string.substring(end_of_text_node);

			({ nodes, string } = parse(string)); // parse following siblings

			return {
				nodes: [ new Node("text", [], text) ].concat(nodes),
				string: string
			};
		}

		function refresh_output() {

			const data = document.getElementById("input").value;

			try {
				document.getElementById("output").innerHTML = new Node("body", parse(data).nodes, {}).to_html();
				document.getElementById("debug").innerHTML = "";
			} catch (e) {
				document.getElementById("debug").innerHTML = "Poorly formatted! " + e;
			}
		}
	</script>
</head>
<body onload="refresh_output();">
	
	<textarea id="input" rows="30" cols="200" oninput="refresh_output();">
[h1]Big header[/]
Here is some text that's cool I guess.
[/br]
Here's another line.
[bul]
	[h2][a https://github.com/dairycultist/MiniSiteParser]Page 1[/][/]
	Here's some info on page 1.
[/]
[bul]
	[h2][a https://github.com/dairycultist/MiniSiteParser]Page 2[/][/]
	Here's some info on page 2.
[/]
[/img https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/60420990-fa4a-4ffb-b409-1f57236c54cf/dh5jlig-a12146f1-f0aa-499b-a8a6-b61cb0782496.jpg/v1/fill/w_720,h_720,q_75,strp/aesthetic_anime_girl_pfp_by_amygamerofc_dh5jlig-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9NzIwIiwicGF0aCI6Ii9mLzYwNDIwOTkwLWZhNGEtNGZmYi1iNDA5LTFmNTcyMzZjNTRjZi9kaDVqbGlnLWExMjE0NmYxLWYwYWEtNDk5Yi1hOGE2LWI2MWNiMDc4MjQ5Ni5qcGciLCJ3aWR0aCI6Ijw9NzIwIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmltYWdlLm9wZXJhdGlvbnMiXX0.mOqbPM93XGqfe5c9lRTT7CGtHBsrhan-BQO926pfcrM]
    </textarea>

	<div id="debug" style="color: red; height: 2em; font-family: monospace;"></div>

	<div id="output">

	</div>

</body>
</html>